#Коннтрак

### Путь пакетов через ядро

Начать стоит с самого начала. Каждый кадр/сетевой пакет представлен в ядре двумя сущностями: собственно сами данные кадра/пакета и структурой socket buffer, которая хранит различную метаинформацию о самом пакете (протокол, длина, указатели за различные заголовки, интерфейсы, через которые пакет пришёл или уйдёт и т.п.), так и внутриядерные служебные данные (счётчик ссылок, указатели на элементы списка для GSO, привязка к ЦПУ и т.п.). Подробнее с содержанием структуры можно ознакомиться [тут](http://lxr.free-electrons.com/source/include/linux/skbuff.h#L626) - там довольно-таки всё интуитивно понятно.

Когда сетевая карта получает кадр по сети, она обычно размещает его в памяти (как правило используя DMA и структуру кольцевого буфера), драйвер заполняет необходимые поля соответствующей пакету структуры skbuff и передаёт кадр в сетевой стек, используя прерывание. Вот тут и начинается самое интересное.

Для мощного файерволла нужно перехватывать пакет на различных стадиях прохождения через сетевой стек. Вот этот перехват и реализуется с помощью подсистемы netfilter. Если совсем просто, то netfilter заведует несколькими списками, которые соответствуют различным участкам прохождения сетевого трафика через стек. Эти перехватчики называются хуками. В данный момент реализованы следующие хуки, соответствующие следующим стадиям обработки:

1. ingress - самая ранняя обработка. появилась в ядре 4.2 и является альтернативой tc ingress queue. Особенностью данного хука является то, что он привязывается к каждому интерфейсу независимо. Поддерживается пока только из nftables. С помощью этого хука можно смотреть привязку трафика к ЦПУ, осуществлять полисинг входящего трафика и т.п.

1. prerouting - на этом этапе системе ещё неизвестно назначение пакета, благодаря чему мы можем им управлять. После этого хука выполняется решение о маршрутизации (route decision). Для ipv4/ipv6 ищется соответствующий маршрут, а так же пакет пропускается через фильтр обратного пути (reverse path filter). Так как на этом этапе дальнейший маршрут ещё неизвестен, то, естественно, мы не знаем выходной интерфейс, а только входящий. Соотвественно, мы так же тут можем использовать только сопоставление по входящему интерфейсу (--input-interface).

В результате route decision мы можем найти следующие типы маршрутов, о которых зависит дальнейшее прохождение пакета:
*. blackhole/unreachable/prohibit - пакет отбрасывается молча или с передачей отправителю пакета icmp
*. local/broadcast - пакет предназначен самому хосту, и передаётся обработчику протокола следующего уровня. Например, для транспортных протоколов будет искаться соответствующий сокет.
*. unicast/multicast - пакет предназначен другому хосту, т.е. является транзитным. Этот пакет будет отправлен в сеть.

1. input - в этот хук попадает трафик, предназначенный самом хосту. После этого трафик идёт к локальному процессу. После этого хука идёт поиск соответствующего сокета и политик безопасности для ipsec и т.п. Причём, для ipsec трафика идёт расшифровка и декапсуляция, и декапсулированные пакеты направляются снова на этап prerouting. Таким образом входящий ipsec-трафик проходит через хук prerouting дважды.

1. forward - через этот хук проходит транзитный трафик. Так как у нас уже есть решение о маршрутизации, то мы знаем выходной интерфейс. Благодаря этому мы можем использовать сопоставления --input-interface и --output-interface.

1. output - только трафик, оригинированный данным хостом, проходит через этот хук. Для новых соединений мы сразу знаем выходной интерфейс и адрес источника, так как решение о маршрутизации принимается в момент передачи данных через сокет от процесса в сетевой стек, при инкапсулации данных на сетевом уровне. Так же тут перепроверка решения о маршрутизации (reroute check).

1. postrouting - последний хук, через который идёт сетевой трафик. На этом этапе так же известен выходной интерфейс, но для, например, оригинированного хостом трафика, входного интерфейса в принципе нет, поэтому в данном хуке мы можем использовать сопоставление по выходному интерфейсу (--output-interface). После хука postrouting трафик так же проходит через политики безопасности. Трафик, попавший под политики, инкапсулируется и шифруется, а потом становится локально-оригинированным, и, соответственно, попадает в хук output.

Следом после всех этих этапов, трафик проходит через подсистему контроля трафика (traffic control - tc), где осуществляется классификация, если необходимо, а так же шейпирование/полисинг (shaping/policing, так же используется более общий термпин scheduling - планирование). После этого трафик передаётся снова в драйвер сетевой карты для последующей передачи в сеть.

Мы кратко рассмотрели хуки, и порядок прохождения сетевого трафика через них. Но что они представляют собой? На самом деле внутри netfilter каждый хук представлен упорядоченным списком. Каждый элемент списка содержит указатель на функцию обратного вызова (callback), которой передаётся структура skbuff пакета и ещё некоторые дополнительные аргументы. 



