#Diving into the internals of the conntrack

### Путь пакетов через ядро и подсистема netfilter

Каждый кадр/ячейка/сетевой пакет (далее мы просто пакет, но надо учитывать контекст, чтобы не было путаницы) представлен в ядре двумя сущностями: собственно сами данные кадра/ячейки/пакета и структурой socket buffer, которая хранит в себе различную метаинформацию как о самом пакете (протокол, длина, указатели за различные заголовки, интерфейсы, через которые пакет пришёл или уйдёт и т.п.), так и внутриядерные служебные данные, ассоциированные с этим пакетом (счётчик ссылок, указатели на элементы списка для GSO, привязка к ЦПУ и очередям и т.п.). В ядре эта структура объявлена следующим образом - [тыц](http://lxr.free-electrons.com/source/include/linux/skbuff.h?v=4.7#L626) - там довольно-таки всё интуитивно понятно названо и, порой, даже прокоментировано. Более подробно человеческим языком о skbuff написано [тут](http://vger.kernel.org/~davem/skb.html). Это нам пригодится для дальнейшего погружения в потроха ядра.

Когда сетевая карта получает кадр по сети, она обычно размещает его в памяти (как правило используя DMA и кольцевой буфер), драйвер заполняет необходимые поля соответствующей пакету структуры skbuff и передаёт её дальше в сетевой стек, используя прерывание. Вот тут-то и начинается самое интересное, хе-хе.

Эта структура проходит через множество этапов обработки, передаётся в функции обработчиков протоколов различного уровня, у неё перезаписываются различные поля, перезаписываются сами данные пакета, и т.д., и т.п. Если нам нужен крутой файерволл, который может много всего, то он обязательно должен уметь обрабатывать трафик на различных этапах  обработки. А чтобы это делать, нужно этот трафик как-то перехватывать на всех этих этапах, и уже передавать в наш файерволл. В ядре линукс этот перехват трафика и реализован в подсистеме с названием netfilter. Эта подсистема предоставляет два внутриядерных интефейса (набора функций, структур и определений функций): один интерфейс для драйверов и обработчиков протоколов, благодаря чему разработчик может предусмотреть перенаправление трафика на обработку файерволлу, а второй интерфейс - для получения трафика на различных этапах обработки - для самой реализации файерволла. Сейчас в ядре существует две реализации файерволла - xtables, которая пришла на смену ipchains, и nftables, которая сейчас очень активно разрабатывается, и вообще суперпрогрессивная и производительная, в которой учтено большинство шишек, набитых во время реалиазации предыдущих реализаций (ух, как сложно и маркетинг-буллшитно получилось!).

Каждый этап обработки сетевого трафика представлен в netfilter в виде хука - точки перехвата. На следующей картинке я кратко нарисовал схему прохождения трафика через эти хуки для ipv4/ipv6 трафика на сетевом уровне (для ethernet трафика на уровне коммутации кадров названия хуков будут немного отличаться, но принцип организации тот же; более полная схема для для всех уровней и с указанием цепочек лежит на [википедии](https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg)).

![Путь пакета через сетевой стек](https://github.com/veryangryman/articles/raw/master/images/p_flow_brief2.png)

Кратко опишу вышеуказанные хуки, и их предназначение.

1. __INGRESS__ - перехват на самом раннем этапе обработки трафика. Этот хук появился в ядре, начиная с версии 4.2 (т.е. относительно совсем недавно), и является альтернативой tc ingress queue, используемой для различных манипуляций с входящим трафиком (классификация, полисинг, перезапись, зеркалирование и перенаправление, и т.п.) Особенностью данного хука является то, что он привязывается к каждому сетевому интерфейсу независимо и опционально. Поддерживается только из nftables и позволяет делать ещё более интересные штуки с входящим трафиком (подробности и примеры использования в [списке рассылки](http://marc.info/?l=netfilter-devel&m=143033337020328&w=2) - выглядит очень вкусно).

1. __PREROUTING__ - на этом этапе системе ещё неизвестно назначение пакета, благодаря чему мы можем повлиять на принятие решения о маршрутизации с помощью перезаписи адресов и меток. Так как дальнейший путь трафика неизвествен, то, соответственно, мы не знаем выходной интерфейс, и по этой причине мы не можем использовать сопоставление по выходному интерфейсу (__--output-interface__ в правилах iptables). После этого хука выполняется поиск маршрута (route lookup). Для ipv4/ipv6 ищется соответствующий маршрут с применением правил маршрутизации (policy based routing), а так же пакет опционально пропускается через фильтр обратного пути (reverse path filter - о нём можно прочитать [здесь](http://lxr.free-electrons.com/source/Documentation/networking/ip-sysctl.txt#L1089)), который с недавнего времени перекочевал в файерволл. В зависимости от типа маршрута, трафик может быть как предназначен как самому хосту (типы маршрутов __local__/__broadcast__/__multicast__), так и транзитным (маршруты типов __unicast__/__multicast__), а может и вообще быть отброшен (маршруты типов __blackhole__/__unreachable__/__prohibit__). Далее трафик пройдёт через различные хуки, в соответствии дальнешему маршруту.

1. __INPUT__ - через этот хук проходит трафик, предназначенный самом хосту. Узнав на предыдущем этапе, что пакеты адресованы самому хосту, трафик передаётся обработчику инкапсулированного протокола (это может быть tcp/udp/sctp/ipsec и т.п.). Например, для транспортных протоколов ищется соответствующий сокет, данные декапсулируются и передаются в найденый сокет. А для IPSEC трафик пропускается через SPDB (база данных политик безопасности), происходит его декапсуляция и расшифровка, а затем он уже в открытом виде инжектируется на этап перед хуком __PREROUTING__. Таким образом, некоторые типы трафика проходят через некоторые хуки дважды в различном виде.

1. __FORWARD__ - через этот хук проходит транзитный трафик, т.е. трафик, который мы пересылаем дальше в сеть другому хосту. Обычно на этом этапе ничего интересного с трафиком не происходит, и он не покидает сетевого уровня. Зная дальнейший путь движения, мы уже можем в файерволлах использовать сопоставление по выходному интерфейсу (__--output-interface__).

1. __OUTPUT__ - только трафик, оригинированный данным хостом, проходит через этот хук. Для новых соединений мы сразу знаем выходной интерфейс и адрес источника, так как решение о маршрутизации принимается в момент передачи данных через сокет от процесса в сетевой стек, при инкапсулации данных на сетевом уровне. Так же тут выполняется перепроверка решения о маршрутизации (reroute check), так мы можем на него повлиять с помощью DNAT, меток и политик маршрутизации. В общем, тоже ничего необычного и суперинтересного.

1. __POSTROUTING__ - последний хук, через который пропускается сетевой трафик. Так же после этого хука трафик может быть пропущен через SPDB, зашифрован и инкапсулирован в IPSEC, а затем инжектирован на этап в районе хука __OUTPUT__. После __POSTROUTING__ трафик передаётся в подсистему __TC__, а далее уже в драйвер сетевого интерфейса.

Мы рассмотрели кратко эти хуки. Но хочется знать как они внутри устроены. На самом деле всё довольно просто оказалось. Каждый хук представляет собой список. Элементы списка - структуры типа [nf_hook_ops](http://lxr.free-electrons.com/source/include/linux/netfilter.h?v=4.7#L87), которые содержат в себе указатель на функцию обратного вызова и приоритет, и ещё немного всякого разного. Эти структуры внутри списка упорядочены по приоритету.

Когда трафик проходит через различные этапы обработки, и его надо передать в файерволл, то в конечном итоге происходит следующее: мы обходим соответствующий хуку список в порядке приоритета элементов, вызываем по указателю коллбек, передавая в него сам пакет и некоторые дополнительные данные.

Если же мы пишем свой файерволл и хотим перехватывать трафик через хуки, то мы регистрируем свой коллбек в заданном хуке с заданным приоритетом. Переданная структура вставляется в соответствующий хуку список в нужную позицию.

Если гипотетически увеличить один из хуков на схеме (возьмём __PREROUTING__, как самый плотный), то получим что-то вроде следующего (для протокола ipv4 для системы с загруженными модулями conntrack, conntrack_defrag, raw и mangle): ![детализация хука PREROUTING](https://github.com/veryangryman/articles/raw/master/images/prert_dets.png). Все эти страшные __NF_IP_PRI_RAW__ и т.п. являются целочисленными знаковыми константами (их можно посмотреть так же в [исходниках](http://lxr.free-electrons.com/source/include/uapi/linux/netfilter_ipv4.h?v=4.7#L57)). Это список будет меняться в зависимости от загруженных модулей, которые при загрузке регистрируют свои функции в хуке, а при выгрузке - разрегистрируют.

Вот этим всем собственно и занимается netfilter. А уже поверх этой инфраструктуры хуков и коллбеков и реализуется подсистемы conntrack, xtables и nftables. Из всего вышеследующего следует несколько неочевидных, но эффективных трюков, позволяющих улучшить производительность вашего файерволла. 

